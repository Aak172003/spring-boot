package com.app.eshop.services;
import com.app.eshop.repositories.UserRepository;
import com.app.eshop.models.User;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;

@Service
@RequiredArgsConstructor
public class UserService {
//    We need to migrate from list based storage to database storage
    private final UserRepository userRepository;

//    This is list based storage we are removing and using database storage
//    private List<User> userList = new ArrayList<>();
//    private Long nextId = 1L;

//    here receive userRepository object with dependency injection
//    we can add constructor like this , but we have one more option like RequiredArgsConstructor whcih do the dame things
//    public UserService(UserRepository userRepository) {
//        this.userRepository = userRepository;
//    }

    public List<User> fetchAllUsers(){

//        System.out.println("fetch user ::::::::::::: " );
//        System.out.println(userList);
//        return  userList;

//        This is database storage approach
        return  userRepository.findAll();
    }

    public Optional<User> fetchUser(Long id){
//        public User fetchUser(Long id){

//        for(User user:userList) {
//            if (user.getId().equals(id)) {
//                return user;
//            }
//        }
//        return null;

//        Compare with id which it receives from where this is called

//        This is list based storage , and above as well , but here we use java feature like streams , but  above we do simply loop

//        return userList.stream()
//                .filter(user -> user.getId().equals(id))
//                .findFirst();

//        This is database storage approach

        Optional<User> getSingleUser =  userRepository.findById(id);
        System.out.println("getSingleUser ------------------- " + getSingleUser);

        return  getSingleUser;

    }


    public void addUserUser(User user){
//        Now we are getting autogenerated unique value because id is now our primary key
//        user.setId(nextId++);
//        userList.add(user);
//        System.out.println("add user ::::::::::::: " );
//        System.out.println(userList);

//        This is database storage approach

       User savedUser =  userRepository.save(user);
       System.out.println("savedUser --------------- " + savedUser);

    }

    public boolean updateUser(Long id , User updatedUser){
//        return userList.stream()
//        .filter(user -> user.getId().equals(id))
//        .findFirst()
//        .map(existingUser ->{
//            existingUser.setFirstName(updatedUser.getFirstName());
//            existingUser.setLastName(updatedUser.getLastName());
//            return  true;
//        })
//        .orElse(false);


//        This is database storage approach
        return userRepository.findById(id)
                .map(existingUser ->{
            existingUser.setFirstName(updatedUser.getFirstName());
            existingUser.setLastName(updatedUser.getLastName());
            userRepository.save(existingUser);
            return true;
        }).orElse(false);

    }

}